{"cells":[{"metadata":{},"cell_type":"markdown","source":"# Задание 1\n\n[Свертка списка](https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%91%D1%80%D1%82%D0%BA%D0%B0_%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0) -  это обобщенная операция над списком, c помощью которой можно преобразовать список в единое значение. Например, рассмотрим реализации свертки слева и свертки справа (левоассоциативную свертку и правоассоциативную свертку):"},{"metadata":{"collapsed":true,"jupyter":{"outputs_hidden":true},"trusted":false},"cell_type":"code","source":"def foldl(f, x0, lst):\n    if not lst:\n        return x0\n    return foldl(f, f(x0, lst[0]), lst[1:])\n\ndef foldr(f, x0, lst):\n    if not lst:\n        return x0\n    return f(lst[0], foldr(f, x0, lst[1:]))","execution_count":2,"outputs":[]},{"metadata":{"trusted":false},"cell_type":"code","source":"#сумма\nfoldl(lambda x, y: x + y, 0, [1, 2, 3])","execution_count":3,"outputs":[{"data":{"text/plain":"6"},"execution_count":3,"metadata":{},"output_type":"execute_result"}]},{"metadata":{"trusted":false},"cell_type":"code","source":"#конкатенация\nfoldl(lambda x, y: '{}{}'.format(x, y), '', [1, 2, 3])","execution_count":4,"outputs":[{"data":{"text/plain":"'123'"},"execution_count":4,"metadata":{},"output_type":"execute_result"}]},{"metadata":{"trusted":false},"cell_type":"code","source":"f = lambda x, y: x / y\nfoldl(f, 1, [1, 2, 3]), \\\nfoldr(f, 1, [1, 2, 3])","execution_count":5,"outputs":[{"data":{"text/plain":"(0.16666666666666666, 1.5)"},"execution_count":5,"metadata":{},"output_type":"execute_result"}]},{"metadata":{},"cell_type":"markdown","source":"Задача: реализовать foldl через foldr и наоборот. Вместо многоточий нужно вставить выражения, которые бы привели к нужному результату. Модифицировать сам список нельзя. "},{"metadata":{"collapsed":true,"jupyter":{"outputs_hidden":true},"trusted":false},"cell_type":"code","source":"def foldl2(f, x0, lst):\n    return foldr(..., ..., lst)(...)","execution_count":6,"outputs":[]},{"metadata":{"collapsed":true,"jupyter":{"outputs_hidden":true},"trusted":false},"cell_type":"code","source":"def foldr2(f, x0, lst):\n    return foldl(..., ..., lst)(...)","execution_count":7,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"# Задание 2\n\nнужно написать функцию, которая принимает две строки и проверяет, входит ли хотя бы одна перестановка второй строки в первую. Например:\n\n> a = 'abcrotm'\n> \n> b = 'tro'\n\nфункция def check_inv(a, b) вернет True, так как 'rot' содержится в 'abcrotm'. Нужно подумать как можно более оптимальный алгоритм и оценить его сложность. "},{"metadata":{"collapsed":true,"jupyter":{"outputs_hidden":true},"trusted":false},"cell_type":"code","source":"from collections import Counter\ndef check_inv(a, b):\n    def is_zeros_dist(cdict):\n        for i in cdict:\n            if cdict[i]!=0:\n                return False\n        return True\n\n    count_b=Counter(b)\n\n    for i in a:\n        if i in count_b.keys() and count_b[i]!=0:\n            count_b[i]-=1\n        else:\n            if is_zeros_dist(count_b):\n                return True\n            else:\n                count_b=Counter(b)\n                if i in count_b.keys() and count_b[i] != 0:\n                    count_b[i] -= 1\n    return is_zeros_dist(count_b)","execution_count":8,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"# Задание 3\n\nРеализовать бинарное дерево (класс Tree), в нём методы __repr__, __str__, __iter__ (итерация только по листьям)."},{"metadata":{"trusted":false},"cell_type":"code","source":"class Tree:\n    def __init__(self, value=None, left=None, right=None):\n        self.left = left\n        self.right = right\n        self.value = value\n\n    def __iter__(self):\n        if not self.left and not self.right:\n            yield self.value\n        if self.left:\n            yield from self.left\n        if self.right:\n            yield from self.right\n\n    def __str__(self):\n        def prchild(self):\n            if self.left != None and self.right != None:\n                str_temp = str(self.value) + '(' + prchild(self.left) + ',' + prchild(self.right) + ')'\n            elif self.left != None:\n                str_temp = str(self.value) + '(' + + prchild(self.left) + ')'\n            elif self.right != None:\n                str_temp = str(self.value) + '(' + prchild(self.right) + ')'\n            else:\n                str_temp = str(self.value)\n            return str_temp\n        str1= str(self.value)+'('+prchild(self.left)+','+prchild(self.right)+')'\n        return str1\n\n    def __repr__(self):\n        def prchild(self):\n            if self.left != None and self.right != None:\n                str_temp =self.__class__.__name__+'('+str(self.value)+','+prchild(self.left)+','+prchild(self.right)+')'\n            elif self.left != None:\n                str_temp = str(self.value) + '(' + + prchild(self.left) + ')'\n            elif self.right != None:\n                str_temp = str(self.value) + '(' + prchild(self.right) + ')'\n            else:\n                str_temp = self.__class__.__name__+'('+str(self.value)+')'\n            return str_temp\n        return prchild(self)\n    \ntree = Tree(0, Tree(1, Tree(3), Tree(4)),                             \n               Tree(2))\n\nlist(tree) == [3, 4, 2]","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"# Задание 4\n\nРеализовать простейший калькулятор математических выражений:\n- только целые числа\n- **+**, **\\-**, **\\***, **\\**\n- скобки\n\n**Можно использовать регулярные выражения**"},{"metadata":{"trusted":false},"cell_type":"code","source":"def calc(expr):\n    def do_opr(obj1,obj2,opr):\n        if opr=='*':\n            return obj1*obj2\n        if opr == '/':\n            return obj1 / obj2\n        if opr=='+':\n            return obj1+obj2\n        if opr=='-':\n            return obj1-obj2\n\n    brack_stec=[]\n    calc_obj=[]\n    temp_calc_obj=[]\n    obj=''\n    opr_stec=[]\n    flag=0\n    i=0\n    while i<len(expr):\n        if expr[i]==' ':\n            pass\n        elif expr[i] in ['0','1','2','3','4','5','6','7','8','9']:\n            obj+=expr[i]\n        elif expr[i] in ['+','-','*', '/']:\n            if obj!='':\n                if flag:\n                    if isinstance(obj,str):\n                        calc_obj.append(-int(obj))\n                        obj = ''\n                    else:\n                        calc_obj.append(obj)\n                        obj = ''\n                    flag=0\n                else:\n                    if isinstance(obj,str):\n                        calc_obj.append(int(obj))\n                        obj = ''\n                    else:\n                        calc_obj.append(obj)\n                        obj = ''\n                opr_stec.append(expr[i])\n            else:\n                flag=1#костыль первого минуса\n        elif expr[i]=='(':\n            brack_stec.append(i)\n            for j in range(len(expr))[i+1::]:\n                if expr[j]==')':\n                    brack_stec.pop()\n                    if len(brack_stec)==0:\n                        obj = calc(expr[i + 1:j])\n                        i = j\n                        break\n                if expr[j]=='(':\n                    brack_stec.append(i)\n        i+=1\n    calc_obj.append(int(obj))\n    opr = opr_stec.pop(0)\n    while len(calc_obj)!=1:\n        if opr in ['+','-']:\n            temp_calc_obj.append(calc_obj.pop(0))\n            while len(opr_stec)!=0 and opr_stec[0] in ['*','/']:\n                obj1=calc_obj.pop(0)\n                obj2=calc_obj.pop(0)\n                calc_obj.insert(0,do_opr(obj1,obj2,opr_stec.pop(0)))\n            else:\n                obj1 = temp_calc_obj.pop()\n                obj2 = calc_obj.pop(0)\n                calc_obj.insert(0,do_opr(obj1,obj2,opr))\n            if len(opr_stec)!=0:#костыль последней операции\n                opr = opr_stec.pop(0)\n        else:\n            while opr in ['*','/']:\n                obj1=calc_obj.pop(0)\n                obj2=calc_obj.pop(0)\n                calc_obj.insert(0,do_opr(obj1,obj2,opr))\n                opr=''\n                if len(opr_stec) != 0:  # костыль последней операции\n                    opr = opr_stec.pop(0)\n    return calc_obj.pop()\n\ncalc('2 * (15 - 3 * 4) - 2') == 4","execution_count":null,"outputs":[]},{"metadata":{"collapsed":true,"jupyter":{"outputs_hidden":true},"trusted":false},"cell_type":"code","source":"","execution_count":null,"outputs":[]}],"metadata":{"kernelspec":{"name":"python3","display_name":"Python 3","language":"python"},"language_info":{"name":"python","version":"3.6.11","mimetype":"text/x-python","codemirror_mode":{"name":"ipython","version":3},"pygments_lexer":"ipython3","nbconvert_exporter":"python","file_extension":".py"}},"nbformat":4,"nbformat_minor":4}